@page "/containers/{ContainerId}"
@rendermode InteractiveServer
@using Microsoft.AspNetCore.SignalR.Client
@using System.Net.Http.Headers
@using AIKnowledge.Core
@inject IHttpClientFactory HttpClientFactory
@inject NavigationManager Navigation
@implements IAsyncDisposable

<PageTitle>@(container?.Name ?? "Files") - AIKnowledge</PageTitle>

@* Header *@
<div class="browser-header">
    <div>
        <nav class="breadcrumb-nav" aria-label="breadcrumb">
            <a href="/" class="breadcrumb-link">Containers</a>
            @if (container is not null)
            {
                <span class="breadcrumb-sep">/</span>
                <a href="/containers/@ContainerId" class="breadcrumb-link" @onclick="NavigateToRoot" @onclick:preventDefault>@container.Name</a>
            }
            @foreach (var crumb in GetBreadcrumbs())
            {
                <span class="breadcrumb-sep">/</span>
                <a href="#" class="breadcrumb-link" @onclick="() => NavigateToPath(crumb.Path)" @onclick:preventDefault>@crumb.Name</a>
            }
        </nav>
    </div>
    <div class="browser-actions">
        <button class="btn btn-sm btn-outline-primary" @onclick="ShowCreateFolderModal">
            <span class="bi-folder-plus me-1"></span> New Folder
        </button>
        <label class="btn btn-sm btn-primary upload-btn-label" for="fileUploadInput">
            <span class="bi-upload me-1"></span> Upload
        </label>
        <InputFile OnChange="HandleFileSelection" multiple
                   accept=".pdf,.md,.txt,.docx,.pptx,.csv,.json,.xml,.yaml,.yml,.html"
                   id="fileUploadInput" style="display: none;" />
    </div>
</div>

@* Loading / Error *@
@if (isLoading)
{
    <div class="text-center py-5">
        <div class="spinner-border text-accent" role="status">
            <span class="visually-hidden">Loading...</span>
        </div>
    </div>
}
else if (errorMessage is not null)
{
    <div class="alert alert-danger">@errorMessage</div>
}
else
{
    @* Upload Drop Zone + File List *@
    <div class="browser-content @(isDragging ? "dragging" : "")"
         @ondragenter="HandleDragEnter"
         @ondragleave="HandleDragLeave"
         @ondragover:preventDefault
         @ondrop="HandleDrop"
         @ondrop:preventDefault>

        @if (isDragging)
        {
            <div class="drop-overlay">
                <div class="drop-overlay-content">
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5z"/>
                        <path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708l3-3z"/>
                    </svg>
                    <span>Drop files to upload to @currentPath</span>
                </div>
            </div>
        }

        @* Upload progress *@
        @if (uploadingFiles.Count > 0)
        {
            <div class="upload-progress-section">
                @foreach (var file in uploadingFiles)
                {
                    <div class="upload-progress-row">
                        <span class="upload-file-name">@file.FileName</span>
                        <span class="upload-file-size">@FormatFileSize(file.SizeBytes)</span>
                        @if (file.Error is not null)
                        {
                            <span class="badge bg-danger">Error</span>
                        }
                        else if (file.State == "Completed")
                        {
                            <span class="badge bg-success">Ready</span>
                        }
                        else if (file.State == "Failed")
                        {
                            <span class="badge bg-danger">Failed</span>
                        }
                        else if (file.State == "Processing")
                        {
                            <div class="upload-progress-bar">
                                <div class="upload-progress-fill" style="width: @(file.PercentComplete)%"></div>
                            </div>
                        }
                        else
                        {
                            <span class="badge bg-secondary">@(file.State ?? "Uploading")</span>
                        }
                    </div>
                }
            </div>
        }

        @* Empty folder state *@
        @if (entries.Count == 0 && uploadingFiles.Count == 0)
        {
            <div class="empty-folder">
                <svg xmlns="http://www.w3.org/2000/svg" width="40" height="40" fill="currentColor" viewBox="0 0 16 16">
                    <path d="M9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.825a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31L.5 3.5V2a2 2 0 0 1 2-2h4.5a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 10.828 2h3.34a2 2 0 0 1 1.992 2.181L15.523 8H1.477l.636 7h10.87l.637-7z"/>
                </svg>
                <p>This folder is empty. Upload files or create a subfolder.</p>
            </div>
        }
        else if (entries.Count > 0)
        {
            @* File/Folder table *@
            <table class="file-table">
                <thead>
                    <tr>
                        <th class="col-name">Name</th>
                        <th class="col-size">Size</th>
                        <th class="col-status">Status</th>
                        <th class="col-modified">Modified</th>
                        <th class="col-actions"></th>
                    </tr>
                </thead>
                <tbody>
                    @foreach (var entry in entries)
                    {
                        <tr class="file-row @(entry.IsFolder ? "folder-row" : "")"
                            @onclick="() => HandleEntryClick(entry)">
                            <td class="col-name">
                                @if (entry.IsFolder)
                                {
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="entry-icon folder-icon" viewBox="0 0 16 16">
                                        <path d="M.54 3.87.5 3a2 2 0 0 1 2-2h3.672a2 2 0 0 1 1.414.586l.828.828A2 2 0 0 0 9.828 3h3.982a2 2 0 0 1 1.992 2.181l-.637 7A2 2 0 0 1 13.174 14H2.826a2 2 0 0 1-1.991-1.819l-.637-7a1.99 1.99 0 0 1 .342-1.31zM2.19 4a1 1 0 0 0-.996 1.09l.637 7a1 1 0 0 0 .995.91h10.348a1 1 0 0 0 .995-.91l.637-7A1 1 0 0 0 13.81 4H2.19z"/>
                                    </svg>
                                }
                                else
                                {
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="entry-icon file-icon" viewBox="0 0 16 16">
                                        <path d="M14 4.5V14a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V2a2 2 0 0 1 2-2h5.5L14 4.5zm-3 0A1.5 1.5 0 0 1 9.5 3V1H4a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1V4.5h-2z"/>
                                    </svg>
                                }
                                <span class="entry-name">@entry.Name</span>
                            </td>
                            <td class="col-size">
                                @if (!entry.IsFolder && entry.SizeBytes.HasValue)
                                {
                                    @FormatFileSize(entry.SizeBytes.Value)
                                }
                            </td>
                            <td class="col-status">
                                @if (!entry.IsFolder && entry.Status is not null)
                                {
                                    <span class="badge @GetStatusBadgeClass(entry.Status)">@entry.Status</span>
                                }
                            </td>
                            <td class="col-modified">
                                @if (entry.LastModified.HasValue)
                                {
                                    @entry.LastModified.Value.ToString("MMM d, yyyy")
                                }
                            </td>
                            <td class="col-actions">
                                <button class="btn btn-sm btn-outline-danger action-btn"
                                        title="Delete"
                                        @onclick="() => ConfirmDeleteEntry(entry)"
                                        @onclick:stopPropagation="true">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" fill="currentColor" viewBox="0 0 16 16">
                                        <path d="M5.5 5.5A.5.5 0 0 1 6 6v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm2.5 0a.5.5 0 0 1 .5.5v6a.5.5 0 0 1-1 0V6a.5.5 0 0 1 .5-.5zm3 .5a.5.5 0 0 0-1 0v6a.5.5 0 0 0 1 0V6z"/>
                                        <path fill-rule="evenodd" d="M14.5 3a1 1 0 0 1-1 1H13v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V4h-.5a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1H6a1 1 0 0 1 1-1h2a1 1 0 0 1 1 1h3.5a1 1 0 0 1 1 1v1zM4.118 4 4 4.059V13a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4.059L11.882 4H4.118zM2.5 3V2h11v1h-11z"/>
                                    </svg>
                                </button>
                            </td>
                        </tr>
                    }
                </tbody>
            </table>
        }
    </div>
}

@* File Detail Panel *@
@if (selectedFile is not null)
{
    <div class="detail-panel">
        <div class="detail-panel-header">
            <h4>File Details</h4>
            <button class="btn-close btn-close-white" @onclick="CloseDetailPanel"></button>
        </div>
        <div class="detail-panel-body">
            <div class="detail-row">
                <span class="detail-label">Name</span>
                <span class="detail-value">@selectedFile.FileName</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Path</span>
                <span class="detail-value detail-path">@selectedFile.Path</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Size</span>
                <span class="detail-value">@FormatFileSize(selectedFile.SizeBytes)</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Type</span>
                <span class="detail-value">@(selectedFile.ContentType ?? "Unknown")</span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Status</span>
                <span class="detail-value">
                    <span class="badge @GetStatusBadgeClass(selectedFile.Metadata.GetValueOrDefault("Status", "Unknown"))">
                        @selectedFile.Metadata.GetValueOrDefault("Status", "Unknown")
                    </span>
                </span>
            </div>
            <div class="detail-row">
                <span class="detail-label">Uploaded</span>
                <span class="detail-value">@selectedFile.CreatedAt.ToString("MMM d, yyyy HH:mm")</span>
            </div>
            @if (selectedFile.Metadata.TryGetValue("ContentHash", out var hash))
            {
                <div class="detail-row">
                    <span class="detail-label">Content Hash</span>
                    <span class="detail-value detail-hash">@hash[..Math.Min(16, hash.Length)]...</span>
                </div>
            }
            @if (selectedFile.Metadata.TryGetValue("ChunkCount", out var chunks))
            {
                <div class="detail-row">
                    <span class="detail-label">Chunks</span>
                    <span class="detail-value">@chunks</span>
                </div>
            }
            @if (selectedFile.Metadata.TryGetValue("IndexedWith:EmbeddingModel", out var model))
            {
                <div class="detail-row">
                    <span class="detail-label">Embedding Model</span>
                    <span class="detail-value">@model</span>
                </div>
            }
            @if (selectedFile.Metadata.TryGetValue("ErrorMessage", out var error) && !string.IsNullOrEmpty(error))
            {
                <div class="detail-row">
                    <span class="detail-label">Error</span>
                    <span class="detail-value text-danger">@error</span>
                </div>
            }
        </div>
        <div class="detail-panel-footer">
            <button class="btn btn-sm btn-outline-danger" @onclick="() => ConfirmDeleteEntry(selectedBrowseEntry!)">
                Delete File
            </button>
        </div>
    </div>
}

@* Create Folder Modal *@
@if (showFolderModal)
{
    <div class="modal-backdrop" @onclick="HideFolderModal"></div>
    <div class="modal-dialog-centered">
        <div class="modal-content-custom">
            <div class="modal-header-custom">
                <h4>Create Folder</h4>
                <button class="btn-close btn-close-white" @onclick="HideFolderModal"></button>
            </div>
            <div class="modal-body-custom">
                <div class="mb-3">
                    <label class="form-label">Folder Name</label>
                    <input type="text" class="form-control" placeholder="my-folder"
                           @bind="newFolderName" @bind:event="oninput" />
                    <small class="text-muted d-block mt-1">Will be created at: @currentPath@newFolderName/</small>
                </div>
                @if (folderError is not null)
                {
                    <div class="alert alert-danger py-2">@folderError</div>
                }
            </div>
            <div class="modal-footer-custom">
                <button class="btn btn-outline-secondary" @onclick="HideFolderModal">Cancel</button>
                <button class="btn btn-primary" @onclick="CreateFolder" disabled="@isCreatingFolder">
                    @if (isCreatingFolder)
                    {
                        <span class="spinner-border spinner-border-sm me-1"></span>
                    }
                    Create
                </button>
            </div>
        </div>
    </div>
}

@* Delete Confirmation Modal *@
@if (entryToDelete is not null)
{
    <div class="modal-backdrop" @onclick="CancelDeleteEntry"></div>
    <div class="modal-dialog-centered">
        <div class="modal-content-custom">
            <div class="modal-header-custom">
                <h4>Delete @(entryToDelete.IsFolder ? "Folder" : "File")</h4>
                <button class="btn-close btn-close-white" @onclick="CancelDeleteEntry"></button>
            </div>
            <div class="modal-body-custom">
                <p>Are you sure you want to delete <strong>@entryToDelete.Name</strong>?</p>
                @if (entryToDelete.IsFolder)
                {
                    <p class="text-warning mb-0">This will delete all files and subfolders inside.</p>
                }
                @if (deleteError is not null)
                {
                    <div class="alert alert-danger py-2 mt-2">@deleteError</div>
                }
            </div>
            <div class="modal-footer-custom">
                <button class="btn btn-outline-secondary" @onclick="CancelDeleteEntry">Cancel</button>
                <button class="btn btn-danger" @onclick="DeleteEntry" disabled="@isDeletingEntry">
                    @if (isDeletingEntry)
                    {
                        <span class="spinner-border spinner-border-sm me-1"></span>
                    }
                    Delete
                </button>
            </div>
        </div>
    </div>
}

@code {
    [Parameter] public string ContainerId { get; set; } = "";

    private ContainerDto? container;
    private List<BrowseEntryDto> entries = new();
    private string currentPath = "/";
    private bool isLoading = true;
    private string? errorMessage;
    private bool isDragging;

    // Folder modal
    private bool showFolderModal;
    private string newFolderName = "";
    private string? folderError;
    private bool isCreatingFolder;

    // Delete modal
    private BrowseEntryDto? entryToDelete;
    private string? deleteError;
    private bool isDeletingEntry;

    // Upload state
    private List<UploadFileInfo> uploadingFiles = new();
    private HubConnection? hubConnection;

    // File detail panel
    private FileDetailDto? selectedFile;
    private BrowseEntryDto? selectedBrowseEntry;

    private HttpClient? _httpClient;
    private HttpClient Http
    {
        get
        {
            if (_httpClient is null)
            {
                _httpClient = HttpClientFactory.CreateClient("BlazorClient");
                _httpClient.BaseAddress = new Uri(Navigation.BaseUri);
            }
            return _httpClient;
        }
    }

    protected override async Task OnInitializedAsync()
    {
        // Initialize SignalR for upload progress
        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/hubs/ingestion"))
            .WithAutomaticReconnect()
            .Build();

        hubConnection.On<IngestionProgressUpdate>("IngestionProgress", HandleIngestionProgress);
        await hubConnection.StartAsync();

        await LoadContainer();
        await LoadEntries();
    }

    private async Task LoadContainer()
    {
        try
        {
            container = await Http.GetFromJsonAsync<ContainerDto>($"/api/containers/{ContainerId}");
        }
        catch
        {
            errorMessage = "Container not found.";
        }
    }

    private async Task LoadEntries()
    {
        isLoading = true;
        errorMessage = null;

        try
        {
            var encodedPath = Uri.EscapeDataString(currentPath);
            var result = await Http.GetFromJsonAsync<List<BrowseEntryDto>>(
                $"/api/containers/{ContainerId}/files?path={encodedPath}");
            entries = result ?? new();
        }
        catch (Exception ex)
        {
            errorMessage = $"Failed to load files: {ex.Message}";
        }
        finally
        {
            isLoading = false;
        }
    }

    private void NavigateToRoot() => NavigateToPath("/");

    private void NavigateToPath(string path)
    {
        currentPath = path;
        _ = LoadEntries();
    }

    private async Task HandleEntryClick(BrowseEntryDto entry)
    {
        if (entry.IsFolder)
        {
            selectedFile = null;
            selectedBrowseEntry = null;
            currentPath = entry.Path;
            await LoadEntries();
        }
        else
        {
            selectedBrowseEntry = entry;
            await LoadFileDetails(entry.Id!);
        }
    }

    private async Task LoadFileDetails(string fileId)
    {
        try
        {
            selectedFile = await Http.GetFromJsonAsync<FileDetailDto>(
                $"/api/containers/{ContainerId}/files/{fileId}");
        }
        catch
        {
            selectedFile = null;
        }
    }

    private void CloseDetailPanel()
    {
        selectedFile = null;
        selectedBrowseEntry = null;
    }

    private List<BreadcrumbItem> GetBreadcrumbs()
    {
        if (currentPath == "/") return new();

        var parts = currentPath.Trim('/').Split('/');
        var crumbs = new List<BreadcrumbItem>();
        var accumulated = "/";

        foreach (var part in parts)
        {
            if (string.IsNullOrEmpty(part)) continue;
            accumulated += part + "/";
            crumbs.Add(new BreadcrumbItem(part, accumulated));
        }

        return crumbs;
    }

    // Drag/drop handlers
    private void HandleDragEnter() => isDragging = true;
    private void HandleDragLeave() => isDragging = false;

    private async Task HandleDrop(DragEventArgs e)
    {
        isDragging = false;
        // File handling via InputFile component
    }

    // Upload
    private async Task HandleFileSelection(InputFileChangeEventArgs e)
    {
        const long maxFileSize = 1024L * 1024 * 500; // 500 MB
        var files = e.GetMultipleFiles(200);

        foreach (var file in files)
        {
            var fileInfo = new UploadFileInfo
            {
                FileName = file.Name,
                SizeBytes = file.Size
            };
            uploadingFiles.Add(fileInfo);
        }
        StateHasChanged();

        foreach (var file in files)
        {
            await UploadFile(file, maxFileSize);
        }
    }

    private async Task UploadFile(IBrowserFile file, long maxFileSize)
    {
        var fileInfo = uploadingFiles.FirstOrDefault(f => f.FileName == file.Name);
        if (fileInfo is null) return;

        try
        {
            using var content = new MultipartFormDataContent();
            using var fileStream = file.OpenReadStream(maxFileSize);
            using var streamContent = new StreamContent(fileStream);
            streamContent.Headers.ContentType = new MediaTypeHeaderValue(
                string.IsNullOrEmpty(file.ContentType) ? "application/octet-stream" : file.ContentType);

            content.Add(streamContent, "files", file.Name);
            content.Add(new StringContent(currentPath), "path");

            var response = await Http.PostAsync($"/api/containers/{ContainerId}/files", content);
            response.EnsureSuccessStatusCode();

            var result = await response.Content.ReadFromJsonAsync<UploadResponseDto>();
            if (result is not null)
            {
                var doc = result.Documents.FirstOrDefault(d => d.FileName == file.Name);
                if (doc is not null)
                {
                    fileInfo.JobId = doc.JobId;
                    fileInfo.Error = doc.Error;

                    if (fileInfo.JobId is not null && hubConnection is not null)
                    {
                        await hubConnection.InvokeAsync("SubscribeToJob", fileInfo.JobId);
                        fileInfo.State = "Queued";
                    }
                }
            }
        }
        catch (Exception ex)
        {
            fileInfo.Error = ex.Message;
        }
        StateHasChanged();
    }

    private async Task HandleIngestionProgress(IngestionProgressUpdate progress)
    {
        await InvokeAsync(() =>
        {
            var file = uploadingFiles.FirstOrDefault(f => f.JobId == progress.JobId);
            if (file is not null)
            {
                file.State = progress.State;
                file.PercentComplete = progress.PercentComplete;

                // Refresh file list when a file completes
                if (progress.State is "Completed" or "Failed")
                {
                    _ = LoadEntries();
                }
                StateHasChanged();
            }
        });
    }

    // Create folder
    private void ShowCreateFolderModal()
    {
        showFolderModal = true;
        newFolderName = "";
        folderError = null;
    }

    private void HideFolderModal() => showFolderModal = false;

    private async Task CreateFolder()
    {
        if (string.IsNullOrWhiteSpace(newFolderName))
        {
            folderError = "Folder name is required.";
            return;
        }

        isCreatingFolder = true;
        folderError = null;

        try
        {
            var folderPath = currentPath + newFolderName.Trim().TrimEnd('/') + "/";
            var request = new { path = folderPath };
            var response = await Http.PostAsJsonAsync($"/api/containers/{ContainerId}/folders", request);

            if (response.IsSuccessStatusCode)
            {
                showFolderModal = false;
                await LoadEntries();
            }
            else
            {
                var error = await response.Content.ReadFromJsonAsync<ErrorResponse>();
                folderError = error?.Error ?? $"Failed to create folder (HTTP {(int)response.StatusCode}).";
            }
        }
        catch (Exception ex)
        {
            folderError = ex.Message;
        }
        finally
        {
            isCreatingFolder = false;
        }
    }

    // Delete entry
    private void ConfirmDeleteEntry(BrowseEntryDto entry)
    {
        entryToDelete = entry;
        deleteError = null;
    }

    private void CancelDeleteEntry() => entryToDelete = null;

    private async Task DeleteEntry()
    {
        if (entryToDelete is null) return;

        isDeletingEntry = true;
        deleteError = null;

        try
        {
            HttpResponseMessage response;

            if (entryToDelete.IsFolder)
            {
                var encodedPath = Uri.EscapeDataString(entryToDelete.Path);
                response = await Http.DeleteAsync(
                    $"/api/containers/{ContainerId}/folders?path={encodedPath}&cascade=true");
            }
            else
            {
                response = await Http.DeleteAsync(
                    $"/api/containers/{ContainerId}/files/{entryToDelete.Id}");
            }

            if (response.IsSuccessStatusCode)
            {
                entryToDelete = null;
                await LoadEntries();
            }
            else
            {
                var error = await response.Content.ReadFromJsonAsync<ErrorResponse>();
                deleteError = error?.Error ?? $"Delete failed (HTTP {(int)response.StatusCode}).";
            }
        }
        catch (Exception ex)
        {
            deleteError = ex.Message;
        }
        finally
        {
            isDeletingEntry = false;
        }
    }

    // Helpers
    private static string FormatFileSize(long bytes)
    {
        string[] sizes = ["B", "KB", "MB", "GB"];
        double len = bytes;
        int order = 0;
        while (len >= 1024 && order < sizes.Length - 1)
        {
            order++;
            len /= 1024;
        }
        return $"{len:0.##} {sizes[order]}";
    }

    private static string GetStatusBadgeClass(string status) => status switch
    {
        "Ready" => "bg-success",
        "Processing" => "bg-info",
        "Pending" => "bg-secondary",
        "Error" => "bg-danger",
        _ => "bg-secondary"
    };

    public async ValueTask DisposeAsync()
    {
        if (hubConnection is not null)
            await hubConnection.DisposeAsync();
    }

    // DTOs
    private record ContainerDto(string Id, string Name, string? Description, DateTime CreatedAt, DateTime UpdatedAt, int DocumentCount);
    private record BrowseEntryDto(string Name, string Path, bool IsFolder, long? SizeBytes, DateTime? LastModified, string? Status, string? Id);
    private record FileDetailDto(string Id, string ContainerId, string FileName, string? ContentType, string Path, long SizeBytes, DateTime CreatedAt, Dictionary<string, string> Metadata);
    private record UploadResponseDto(string? BatchId, List<UploadedDocDto> Documents, int TotalCount, int SuccessCount);
    private record UploadedDocDto(string DocumentId, string? JobId, string FileName, long SizeBytes, string Path, string? Error);
    private record ErrorResponse(string? Error);
    private record BreadcrumbItem(string Name, string Path);

    private record IngestionProgressUpdate(
        string JobId,
        string State,
        string? CurrentPhase,
        double PercentComplete,
        string? ErrorMessage,
        DateTime? StartedAt,
        DateTime? CompletedAt);

    private class UploadFileInfo
    {
        public string FileName { get; set; } = "";
        public long SizeBytes { get; set; }
        public string? JobId { get; set; }
        public string? State { get; set; }
        public double PercentComplete { get; set; }
        public string? Error { get; set; }
    }
}
